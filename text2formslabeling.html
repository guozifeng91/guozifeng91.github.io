<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LABELLER</title>
    <style media="screen">
      *{
        margin: 0;
        padding: 0;
        /* font-family: sans-serif; */
        font-family: 'Courier New', monospace;
      }
    </style>
    <link rel="stylesheet" href="./stylesheet.css">
    <link rel="stylesheet" href="./style-amended.css">
  </head>
  <body>
    <header class="site-header" data-context="theme.topcontainer" data-hover-hint="header">
        <div class="logo-wrap" data-hover-hint="logo">
              <div class="logo">
                <a id="home-link" href="./index.html?position=1">
                <svg xmlns="http://www.w3.org/2000/svg" width="100%" viewBox="0 0 98.4533 46.3838"><defs><style>.a{font-size:12px;fill:#231815;font-family:CourierNewPSMT, Courier New;}.b{letter-spacing:0.1757em;}.c{letter-spacing:0.198em;}.d{letter-spacing:0.6673em;}.e{letter-spacing:-0.0151em;}</style></defs><text class="a" transform="translate(0.0004 9.4276)"><tspan class="b">TOWARD</tspan><tspan x="55.855" y="0">S</tspan><tspan class="c" x="63.0562" y="0"> </tspan><tspan class="b" x="72.6338" y="0">TH</tspan><tspan x="91.252" y="0">E</tspan><tspan class="d" x="0" y="14.3999">DIGITA</tspan><tspan x="91.252" y="14.3999">L</tspan><tspan class="e" x="0" y="28.7998">ARCHITECTONIC</tspan><tspan x="91.252" y="28.7998">S</tspan></text></svg>
                    <!-- <a href="./index.html" class="preserve-whitespace" style="color: #404040">TOWARDS THE DIGITAL ARCHITECTONIC</a> -->
                </a>
              </div>
        </div>
    </header>
    <script type="text/javascript" src="./checkhomeaddress.js"></script>

    <div class="project-container-wrapper">
      <div id="project-container" class="project-container">
        <!-- <section class="project-covers" data-context="page.gallery.covers"> -->
          <div id="indicator" class="project-title">
            Texts to Forms Labeller
          </div>

          <div class="project-text-centered">
            <input type="button" id="but_start" value="please wait"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
          </div>

          <div id="section_labeling" class="project-text-centered" hidden="hidden">
            <canvas id="canvas_geo" width="600" height="400" style="width:100%; border: 1px solid black;"></canvas>
            <br>
            <br>
            <p id="adj_text">adjective</p>
            <br>

            <div style="width:100%; display:flex; flex-direction:row; justify-content: center; column-gap: 1em;">
            <input type="button" id="adj_opt_1" value="left"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
            <input type="button" id="adj_opt_2" value="right"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
            </div>
            <br>

            <div style="width:100%; display:flex; flex-direction:row; justify-content: center; column-gap: 1em;">
            <input type="text" id="user_id_input" placeholder="Type you name here"  class="project-text-centered" style="width:15em; height:2em; padding-top:0;padding-bottom:0;">
            <input type="button" id="save_op" value="Save JSON"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
            </div>
          </div>
          <div class="project-text-centered">-</div>
        <!-- </section> -->
      </div>
    </div>

    <!-- threejs for 3D visualization -->
    <script async="" src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
			{
				"imports": {
					"three": "./jslibs/threejs/three.module.js"
				}
			}
		</script>

    <script type="text/javascript">
      let xyz=null;
      let forces=null;
      let topology=null;

      const dataset_version="1.0";
      const root_path='https://storage.googleapis.com/zfguo_pretrained_models/cem_labeling/';
      const indicator=document.getElementById('indicator');

      function fetch_geometry(i){
        // returns the i-th geomtry as a list of point pairs
        // i.e., list of [x1,y1,z1,x2,y2,z2]
        const num_e = topology.length;
        const xyz_i = xyz[i];
        const num = xyz_i.length/3;
        const xs = xyz_i.slice(0, num);
        const ys = xyz_i.slice(num, num*2);
        const zs = xyz_i.slice(num*2, num*3);

        const lines = new Array(num_e);
        for (let index=0; index<topology.length; index++){
          const t=topology[index];
          const s = t[0];
          const e = t[1];
          lines[index]= [xs[s],ys[s],zs[s],xs[e],ys[e],zs[e]];
        }

        return lines;
      }

      function fetch_forces(i){
        return forces[i];
      }
      // dummy dataset of forms and adjectives
      let adjectives=['balanced','strong','heavy','simple','complex','iconic','interesting','boring','stable','strange','light'];
      // change the above dummy dataset to real dataset

      let labels=[]; // list of 3 integers, representing 1: which adj, 2 and 3: which forms. The order of 2 and 3 depends on user's decision
      let current_i=-1,current_j=-1,current_adj=-1;
    </script>

    <script type="text/javascript">
      // load NPY files
      // decode NPY format
      function make_arr(descr, arr, offset){
        // console.log('descr',descr);
        if (descr=="|u1") {
          return new Uint8Array(arr,offset);
        } else if (descr=="<i4") {
          return new Int32Array(arr,offset);
        } else if (descr=="<f4") {
          return new Float32Array(arr,offset);
        } else if (descr=="<f8") {
          return new Float64Array(arr,offset);
        } else {
          console.log("no implement");
        }
      }

      function createArray(length) {
        // code for creating nd-array, taken from
        // https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
        var arr = new Array(length || 0),
        i = length;

        if (arguments.length > 1) {
          var args = Array.prototype.slice.call(arguments, 1);
          while(i--) arr[length-1 - i] = createArray.apply(this, args);
        }
        return arr;
      }

      function reshape_naive(npy){
        const data=npy['data'];
        const shape=npy['shape'];
        const [row, col] = shape;
        const output = createArray(row);

        for (let r=0;r<row;r++){
          output[r] = data.slice(r*col, (r+1)*col);
        }

        return output;
      }

      function parse_npy(buff) {
        // const version = arrayBufferContents.slice(6, 8); // Uint8-encoded
        const hlen = new DataView(buff.slice(8, 10)).getUint8(0);
        const offset = 10 + hlen;
        const hstr = new TextDecoder("utf-8").decode(
            new Uint8Array(buff.slice(10, 10 + hlen))
        ).toLowerCase().replaceAll("(","[").replaceAll("),","]").replaceAll(",]","]").replaceAll("'","\"");
        // console.log(hstr);
        const header = JSON.parse(hstr);
        return {"data":make_arr(header["descr"], buff, offset), "shape": header["shape"]};
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      let camera, scene, renderer;
      let mesh_1=null, mesh_2=null;

      // const material_blue = new THREE.LineBasicMaterial( { color: 0x0578be } );
      // const material_red = new THREE.LineBasicMaterial( { color: 0xc81414 } );
      const material_blue = new THREE.MeshBasicMaterial( { color: 0x0578be} );
      const material_red = new THREE.MeshBasicMaterial( { color: 0xc81414} );

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera( 30, 1.5, 1, 1000 );
        camera.position.y = 25;
        camera.position.z = 150;

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer( { antialias: true, canvas: document.getElementById("canvas_geo")} );
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio( window.devicePixelRatio );

        window.addEventListener( 'resize', onWindowResize );
        scene.add(new THREE.GridHelper( 1000, 50 ));
      }

      function onWindowResize() {
        // camera.aspect = window.innerWidth / window.innerHeight;
        // camera.updateProjectionMatrix();
        // renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        requestAnimationFrame( animate );
        if (mesh_1!=null){
          mesh_1.rotation.y += 0.01;
        }
        if (mesh_2!=null){
          mesh_2.rotation.y += 0.01;
        }

        renderer.render( scene, camera );
      }

      function get_mesh(i){
        // pipe class
        class crv extends THREE.Curve{
          constructor(segment,e) {
            super();
            this.dx=segment[3]-segment[0];
            this.dy=segment[4]-segment[1];
            this.dz=segment[5]-segment[2];

            this.x=segment[0];
            this.y=segment[1];
            this.z=segment[2];
          }
          getPoint(t, optionalTarget = new THREE.Vector3()) {
            const tx = t * this.dx + this.x;
            const ty = t * this.dy + this.y;
            const tz = t * this.dz + this.z;
            return optionalTarget.set( tx, tz, ty );
          }
        }

        const xyzs=fetch_geometry(i);
        const forces=fetch_forces(i);
        const num_edges=xyzs.length;
        const lines=new THREE.Group();

        for (let index=0;index<num_edges;index++){
          let material;

          if (forces[index]<0){
            material=material_blue;
          } else {
            material=material_red;
          }
          // pipes
          const geometry = new THREE.TubeGeometry(new crv(xyzs[index]), 1, Math.max(0.2,Math.abs(forces[index])/150), 3, false );
          const line = new THREE.Mesh(geometry, material);
          lines.add(line);
        }

        // translate the geometries such that they are centered w.r.t. the bbox
        const translate = new THREE.Box3().setFromObject(lines).getCenter(new THREE.Vector3()).multiplyScalar(-1).setY(0);
        for (let c of lines.children){
          c.geometry.translate(...translate);
        }

        // note that the mesh can now to moved by setting mesh.position
        return lines;
      }

      function on_new_mesh(i, j) {
        // display new mesh pairs i and j
        mesh_1=get_mesh(i);
        mesh_2=get_mesh(j);

        mesh_1.position.add(new THREE.Vector3(-30,0,0));
        mesh_2.position.add(new THREE.Vector3(30,0,0));

        scene.add(mesh_1);
        scene.add(mesh_2);
      }

      function remove_mesh(mesh){
        if (mesh!=null){
          scene.remove(mesh);
          for (let m of mesh.children){
            m.geometry.dispose();
          }
        }
      }

      const start_button=document.getElementById("but_start");
      const section_labeling=document.getElementById("section_labeling");
      const adj_opt_1=document.getElementById("adj_opt_1");
      const adj_opt_2=document.getElementById("adj_opt_2");
      const adj_text=document.getElementById("adj_text");
      const save_op=document.getElementById("save_op");

      function next_sample_rand (){
        remove_mesh(mesh_1);
        remove_mesh(mesh_2);

        // returns a pair of forms and a adjective, all are randomly sampled
        const num_f = xyz.length;
        const num_a = adjectives.length;
        current_i = Math.floor(num_f*Math.random());
        current_j = current_i;
        while (current_i==current_j){
          current_j=Math.floor(num_f*Math.random());
        }
        current_adj = Math.floor(num_a*Math.random());
        adj_text.innerHTML=(1 + labels.length).toString() + ". which form is more \"" + adjectives[current_adj] + "\"?";
        on_new_mesh(current_i, current_j);
      }

      function fetch_npy_operation(path, callback=null, callback_async=null){
        return (function(){
          // return a callable which
          // 1. fetch and parse the npy data as specified by path
          // 2. evaluate the callback function using the parsed npy as the argument
          // 3. evaluate the callback_async function, if any.
          fetch(path, {}).then((resp)=>{
            resp.arrayBuffer().then((buff)=>{
              const npy = parse_npy(buff);
              if (callback!=null){
                callback(npy);
              }

              if (callback_async!=null){
                callback_async();
              }
            });
          });
        });
      }

      function export2json() {
        const a = document.createElement("a");
        const user_id=document.getElementById("user_id_input").value;
        a.href = URL.createObjectURL(new Blob([JSON.stringify({"user_id":user_id, "dataset_version":dataset_version, "user_labels":labels}, null, 2)], {
          type: "text/plain"
        }));
        a.setAttribute("download", user_id + "-labels.json");
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      function reg_ops(){
        start_button.onclick=()=>{section_labeling.hidden=""; start_button.hidden="hidden";}
        adj_opt_1.onclick=()=>{labels.push({"id":labels.length, "adj":adjectives[current_adj], "adj_id":current_adj, "form_id_user_choice":current_i, "form_id_control":current_j, "timestamp":Date.now()}); next_sample_rand();};
        adj_opt_2.onclick=()=>{labels.push({"id":labels.length, "adj":adjectives[current_adj], "adj_id":current_adj, "form_id_user_choice":current_j, "form_id_control":current_i, "timestamp":Date.now()}); next_sample_rand();};
        save_op.onclick=()=>{export2json();};
      }

      const op_xyz = fetch_npy_operation(root_path+'cem-dataset_node-xyz.npy',
      (x)=>{indicator.innerHTML='Loading Node XYZ (9MB) ...'; xyz=reshape_naive(x);},
      ()=>{indicator.innerHTML='Texts to Forms Labeller'; start_button.value="start"; reg_ops(); next_sample_rand();});
      const op_forces = fetch_npy_operation(root_path+'cem-dataset_edge-forces.npy',(x)=>{indicator.innerHTML='Loading Edge Forces (7MB) ...'; forces=reshape_naive(x);},op_xyz);
      const op_topology = fetch_npy_operation(root_path+'cem-dataset_topology.npy',(x)=>{indicator.innerHTML='Loading Topology (1MB) ...'; topology=reshape_naive(x);},op_forces);

      op_topology();
    </script>
  </body>
</html>
