<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LABELLER</title>
    <style media="screen">
      *{
        margin: 0;
        padding: 0;
        /* font-family: sans-serif; */
        font-family: 'Courier New', monospace;
      }
    </style>
    <link rel="stylesheet" href="./stylesheet.css">
    <link rel="stylesheet" href="./style-amended.css">
  </head>
  <body>
    <header class="site-header" data-context="theme.topcontainer" data-hover-hint="header">
        <div class="logo-wrap" data-hover-hint="logo">
              <div class="logo">
                <a id="home-link" href="./index.html?position=1">
                <svg xmlns="http://www.w3.org/2000/svg" width="100%" viewBox="0 0 98.4533 46.3838"><defs><style>.a{font-size:12px;fill:#231815;font-family:CourierNewPSMT, Courier New;}.b{letter-spacing:0.1757em;}.c{letter-spacing:0.198em;}.d{letter-spacing:0.6673em;}.e{letter-spacing:-0.0151em;}</style></defs><text class="a" transform="translate(0.0004 9.4276)"><tspan class="b">TOWARD</tspan><tspan x="55.855" y="0">S</tspan><tspan class="c" x="63.0562" y="0"> </tspan><tspan class="b" x="72.6338" y="0">TH</tspan><tspan x="91.252" y="0">E</tspan><tspan class="d" x="0" y="14.3999">DIGITA</tspan><tspan x="91.252" y="14.3999">L</tspan><tspan class="e" x="0" y="28.7998">ARCHITECTONIC</tspan><tspan x="91.252" y="28.7998">S</tspan></text></svg>
                    <!-- <a href="./index.html" class="preserve-whitespace" style="color: #404040">TOWARDS THE DIGITAL ARCHITECTONIC</a> -->
                </a>
              </div>
        </div>
    </header>
    <script type="text/javascript" src="./checkhomeaddress.js"></script>

    <div class="project-container-wrapper">
      <div id="project-container" class="project-container">
        <!-- <section class="project-covers" data-context="page.gallery.covers"> -->
          <div id="indicator" class="project-title">
            Texts to Forms Labeller
          </div>

          <div class="project-text-centered">
            <p>3D form canvas</p>
            <canvas id="canvas_geo" width="300" height="300" style="border: 1px solid black;"></canvas>
          </div>

          <div class="project-text-centered">
            <p id="adj_text">adjective</p>
            <input type="button" id="adj_opt_1" value="form 1"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
            <input type="button" id="adj_opt_2" value="form 2"  class="project-text-centered" style="width:10em; height:2em; padding-top:0;padding-bottom:0;">
          </div>
          <div class="project-text-centered">-</div>
        <!-- </section> -->
      </div>
    </div>

    <!-- threejs for 3D visualization -->
    <script async="" src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
			{
				"imports": {
					"three": "./jslibs/threejs/three.module.js"
				}
			}
		</script>

    <script type="text/javascript">
      let xyz=null;
      let forces=null;
      let topology=null;
      const root_path='https://storage.googleapis.com/zfguo_pretrained_models/cem_labeling/';
      const indicator=document.getElementById('indicator');

      function fetch_geometry(i){
        // returns the i-th geomtry as a list of point pairs
        // i.e., list of [x1,y1,z1,x2,y2,z2]
        const num_e = topology.length;
        const xyz_i = xyz[i];
        const num = xyz_i.length/3;
        const xs = xyz_i.slice(0, num);
        const ys = xyz_i.slice(num, num*2);
        const zs = xyz_i.slice(num*2, num*3);

        const lines = new Array(num_e);
        for (let index=0; index<topology.length; index++){
          const t=topology[index];
          const s = t[0];
          const e = t[1];
          lines[index]= [xs[s],ys[s],zs[s],xs[e],ys[e],zs[e]];
        }

        return lines;
      }

      function fetch_forces(i){
        return forces[i];
      }

      // dummy dataset of forms and adjectives
      let forms=[0,1,2,3,4,5,6,7,8,9];
      let adjectives=['adj1','adj2','adj3'];
      // change the above dummy dataset to real dataset

      let labels=[]; // list of 4 integers, representing 1: which adj, 2 and 3: which forms, and 4: labels (on if the -1, 0, 1)

      function next_sample_rand (){
        // returns a pair of forms and a adjective, all are randomly sampled
        const num_f = forms.length;
        const num_a = adjectives.length;
        const form_1 = Math.random(num_f);
        let form_2 = form_1;
        while (form_1==form_2){
          form_2=Math.random(num_f);
        }
        const adj = Math.random(num_a);

        return [form_1, form_2, adj];
      }
    </script>

    <script type="module">
      // load NPY files
      // decode NPY format
      function make_arr(descr, arr, offset){
        // console.log('descr',descr);
        if (descr=="|u1") {
          return new Uint8Array(arr,offset);
        } else if (descr=="<i4") {
          return new Int32Array(arr,offset);
        } else if (descr=="<f4") {
          return new Float32Array(arr,offset);
        } else if (descr=="<f8") {
          return new Float64Array(arr,offset);
        } else {
          console.log("no implement");
        }
      }

      function createArray(length) {
        // code for creating nd-array, taken from
        // https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
        var arr = new Array(length || 0),
        i = length;

        if (arguments.length > 1) {
          var args = Array.prototype.slice.call(arguments, 1);
          while(i--) arr[length-1 - i] = createArray.apply(this, args);
        }
        return arr;
      }

      function reshape_naive(npy){
        const data=npy['data'];
        const shape=npy['shape'];
        const [row, col] = shape;
        const output = createArray(row);

        for (let r=0;r<row;r++){
          output[r] = data.slice(r*col, (r+1)*col);
        }

        return output;
      }

      function parse_npy(buff) {
        // const version = arrayBufferContents.slice(6, 8); // Uint8-encoded
        const hlen = new DataView(buff.slice(8, 10)).getUint8(0);
        const offset = 10 + hlen;
        const hstr = new TextDecoder("utf-8").decode(
            new Uint8Array(buff.slice(10, 10 + hlen))
        ).toLowerCase().replaceAll("(","[").replaceAll("),","]").replaceAll(",]","]").replaceAll("'","\"");
        // console.log(hstr);
        const header = JSON.parse(hstr);
        return {"data":make_arr(header["descr"], buff, offset), "shape": header["shape"]};
      }

      function fetch_npy_operation(path, callback=null, callback_async=null){
        return (function(){
          // return a callable which
          // 1. fetch and parse the npy data as specified by path
          // 2. evaluate the callback function using the parsed npy as the argument
          // 3. evaluate the callback_async function, if any.
          fetch(path, {}).then((resp)=>{
            resp.arrayBuffer().then((buff)=>{
              const npy = parse_npy(buff);
              if (callback!=null){
                callback(npy);
              }

              if (callback_async!=null){
                callback_async();
              }
            });
          });
        });
      }

      const op_xyz = fetch_npy_operation(root_path+'cem-dataset_node-xyz.npy', (x)=>{indicator.innerHTML='Loading Node XYZ (9MB) ...'; xyz=reshape_naive(x);},()=>{indicator.innerHTML='OK';});
      const op_forces = fetch_npy_operation(root_path+'cem-dataset_edge-forces.npy',(x)=>{indicator.innerHTML='Loading Edge Forces (7MB) ...'; forces=reshape_naive(x);},op_xyz);
      const op_topology = fetch_npy_operation(root_path+'cem-dataset_topology.npy',(x)=>{indicator.innerHTML='Loading Topology (1MB) ...'; topology=reshape_naive(x);},op_forces);

      op_topology();
    </script>

    <!-- 3d renderings -->
    <script type="module">
			import * as THREE from 'three';

			let camera, scene, renderer;
			let mesh_1=null, mesh_2=null;

      // const material_blue = new THREE.LineBasicMaterial( { color: 0x0578be } );
      // const material_red = new THREE.LineBasicMaterial( { color: 0xc81414 } );
      const material_blue = new THREE.MeshBasicMaterial( { color: 0x0578be} );
      const material_red = new THREE.MeshBasicMaterial( { color: 0xc81414} );

			init();
			animate();

			function init() {
				camera = new THREE.PerspectiveCamera( 70, 1, 1, 1000 );
				camera.position.z = 100;

				scene = new THREE.Scene();

				const texture = new THREE.TextureLoader().load( './gallery/thumbs/cv.gif' );

				const geometry = new THREE.BoxGeometry( 200, 200, 200 );
				const material = new THREE.MeshBasicMaterial( { map: texture } );

				renderer = new THREE.WebGLRenderer( { antialias: true, canvas: document.getElementById("canvas_geo")} );
        renderer.setClearColor(0xffffff);
				renderer.setPixelRatio( window.devicePixelRatio );
				// renderer.setSize( window.innerWidth, window.innerHeight );
				// document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );
			}

			function onWindowResize() {
				// camera.aspect = window.innerWidth / window.innerHeight;
				// camera.updateProjectionMatrix();
				// renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
        if (mesh_1!=null){
  				mesh_1.rotation.y += 0.01;
        }
        if (mesh_2!=null){
          mesh_2.rotation.y += 0.01;
        }

				renderer.render( scene, camera );
			}

      function remove_mesh(mesh){
        scene.remove(mesh);
        for (let m of mesh.children){
          m.geometry.dispose();
        }
      }

      function get_mesh(i){
        // pipe class
        class crv extends THREE.Curve{
          constructor(segment,e) {
            super();
            this.dx=segment[3]-segment[0];
            this.dy=segment[4]-segment[1];
            this.dz=segment[5]-segment[2];

            this.x=segment[0];
            this.y=segment[1];
            this.z=segment[2];
          }
          getPoint(t, optionalTarget = new THREE.Vector3()) {
            const tx = t * this.dx + this.x;
            const ty = t * this.dy + this.y;
            const tz = t * this.dz + this.z;
            return optionalTarget.set( tx, tz, ty );
          }
        }
        const xyzs=fetch_geometry(i);
        const forces=fetch_forces(i);
        const num_edges=xyzs.length;
        const lines=new THREE.Group();

        for (let index=0;index<num_edges;index++){
          let material;

          if (forces[index]<0){
            material=material_blue;
          } else {
            material=material_red;
          }
          // pipes
          const geometry = new THREE.TubeGeometry(new crv(xyzs[index]), 1, Math.max(0.2,Math.abs(forces[index])/150), 3, false );
          const line = new THREE.Mesh(geometry, material);
          lines.add(line);
        }

        // translate the geometries such that they are centered w.r.t. the bbox
        const translate = new THREE.Box3().setFromObject(lines).getCenter(new THREE.Vector3()).multiplyScalar(-1);
        for (let c of lines.children){
          c.geometry.translate(...translate);
        }

        // note that the mesh can now to moved by setting mesh.position
        return lines;
      }

      function on_new_mesh(i, j) {
        // display new mesh pairs i and j
        mesh_1=get_mesh(i);
        mesh_2=get_mesh(j);

        mesh_1.position.add(new THREE.Vector3(-30,0,0));
        mesh_2.position.add(new THREE.Vector3(30,0,0));

        scene.add(mesh_1);
        scene.add(mesh_2);
      }

      document.getElementById("adj_opt_1").onclick=function(e){
        console.log("a");
        const [i,j,a] = next_sample_rand();
        on_new_mesh(0,1);
      };

      document.getElementById("adj_opt_2").onclick=function(e){
        console.log('b');
        remove_mesh(mesh_1);
        remove_mesh(mesh_2);
      };
    </script>
  </body>
</html>
