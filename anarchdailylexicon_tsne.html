<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AN ARCHDAILY LEXICON - DEMO</title>
  <style media="screen">
  *{
    margin: 0;
    padding: 0;
    /* font-family: sans-serif; */
    font-family: 'Courier New', monospace;
  }
  </style>
  <link rel="stylesheet" href="./stylesheet.css">
  <!-- <link rel="stylesheet" href="./style-amended.css"> -->

  <!-- amended style for this page -->
  <style media="screen">
    .name_and_cover_container{
      display:flex;
      flex-direction:column;
      line-height:normal;
      text-align: center;
    }

    .square_image_container{
      position:relative; width:100%; padding-bottom:100%; overflow:hidden;
    }

    .square_image_content{
      position:absolute; height:100%; width:100%; left:0; top:0; object-fit: cover;
    }

    .name_tag_fix_height{
      min-height: 6em;
      max-height: 6em;
    }

    .ios-bottom-adjust{
      bottom:0em;
    }

    .bake_area{
      position: relative;
      min-height: 35vh;
      margin-left: 2em;
      margin-right: 2em;
      width:auto;

      top:250px;
      max-height: calc(100vh - 300px);
      overflow: auto;
    }

    .bake-container{
      position: relative;
      display: grid;
      flex-wrap: wrap;
      flex-direction: row;
      height: 100%;
      width: 100%;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 5px;
    }

    @media screen and (max-width: 680px) {
      .ios-bottom-adjust{
        bottom:6em;
      }
      .bake_area{
        position: relative;
        min-height: 35vh;
        margin-left: 2em;
        margin-right: 2em;
        width:auto;

        top:200px;
        max-height: calc(100vh - 400px);
        overflow: auto;
      }
    }

    .p-button{
      position: relative;
      width: 100%;
      /* left:50%;
      transform:translateX(-50%); */
      cursor:pointer;
      font-weight:bold;
      z-index:1;
      margin: 0.5em;
      border-style: solid;
      border-width: thin;
      border-color: #ffffffa0;
    }

    .p-button:hover{
      border-style: solid;
      border-width: thin;
      border-color: #ffffff;
      background-color: #000000a0;
    }
  </style>
  <!-- constants -->
  <script type="text/javascript" src="anarchdailylexicon/data/namelist.js"></script>
  <script type="text/javascript" src="anarchdailylexicon/data/urllist.js"></script>
  <script type="text/javascript" src="anarchdailylexicon_full/data/indexlist.js"></script>
</head>
<body>
  <div style="position: relative; width:100vw; height:100vh; background-color: #000000">
    <div class="logo" style="z-index: 1;">
      <a id="home-link" href="./index.html?position=1">
        <svg xmlns="http://www.w3.org/2000/svg" width="100%" viewBox="0 0 98.4533 46.3838"><defs><style>.a{font-size:12px;fill:#a0a0a0;font-family:CourierNewPSMT, Courier New;}.b{letter-spacing:0.1757em;}.c{letter-spacing:0.198em;}.d{letter-spacing:0.6673em;}.e{letter-spacing:-0.0151em;}</style></defs><text class="a" transform="translate(0.0004 9.4276)"><tspan class="b">TOWARD</tspan><tspan x="55.855" y="0">S</tspan><tspan class="c" x="63.0562" y="0"> </tspan><tspan class="b" x="72.6338" y="0">TH</tspan><tspan x="91.252" y="0">E</tspan><tspan class="d" x="0" y="14.3999">DIGITA</tspan><tspan x="91.252" y="14.3999">L</tspan><tspan class="e" x="0" y="28.7998">ARCHITECTONIC</tspan><tspan x="91.252" y="28.7998">S</tspan></text></svg>
        <!-- <a href="./index.html" class="preserve-whitespace" style="color: #404040">TOWARDS THE DIGITAL ARCHITECTONIC</a> -->
      </a>
    </div>

    <div id="bake_background" style="position: absolute; z-index: -1; width:100vw; height:100vh; left:0; top:0; background-color: #000000c0">
      <div class="bake_area">
        <div id="bake_output" class="bake-container" style="gap: 10px;">
          <!-- search output here  -->
        </div>
      </div>
    </div>

    <div class="project-text-centered ios-bottom-adjust" style="position: absolute; width: 100%; color:#ffffff;">
      <div id="buttons" style="position:relative; display:flex; flex-direction: row; width:15em; left:50%; transform:translateX(-50%); z-index:1;">
        <p id="button_bake" class="p-button" style="padding:0">bake</p>
        <p id="button_mode" class="p-button" style="padding:0">Mode</p>
      </div>
    </div>

    <div class="project-text-centered" style="color:#a0a0a0; top: 50vh">
      <p id="indicator">Initializing, please wait...</p>
    </div>

    <script type="text/javascript" src="./checkhomeaddress.js"></script>
    <canvas id="main_canvas" width="1024px" height="512px" style="position: absolute; top:0; width:100vw; height:100vh"></canvas>
  </div>
  <script type="text/javascript">
    const indicator=document.getElementById('indicator');
    const button_mode=document.getElementById('button_mode');
    const button_bake=document.getElementById('button_bake');
    const bake_background = document.getElementById("bake_background");
    const bake_output = document.getElementById("bake_output");

    const remove_all_entries = function(){
      const container=bake_output;
      while (container.firstChild) {
        const c = container.lastChild;
        container.removeChild(c);
        c.remove();
      }
    };

    const add_entry = function(url_target, url_img='./gallery/thumbs/agentlamp.gif', target='_blank'){
      const container = bake_output;
      const ele_cover = document.createElement("div");
      ele_cover.className="project-cover-gallery";
      // console.log(v2);
      const ele_link = document.createElement("a");
      ele_link.href=url_target;

      const ele_wrapper=document.createElement('div');
      ele_wrapper.className="name_and_cover_container";
      const ele_wrapper_img=document.createElement('div');
      ele_wrapper_img.className="square_image_container";

      const ele_img = document.createElement("img");
      // const ele_name = document.createElement("p");
      // ele_name.innerHTML=name;
      // ele_name.className="name_tag_fix_height";

      ele_img.src=url_img;
      ele_img.className="square_image_content";

      if (target!=null){ ele_link.target=target;}

      ele_cover.appendChild(ele_link);
      ele_link.appendChild(ele_wrapper);
      ele_wrapper.appendChild(ele_wrapper_img);
      // ele_wrapper.appendChild(ele_name);
      ele_wrapper_img.appendChild(ele_img);

      container.appendChild(ele_cover);
    };

    const Z_MAX=8.9;
    const Z_MIN=0;
    const Z_COUNT=9;
    const PATCH_SIZE_PX = 256; // patch size, must be 256 as the coords are saved in uint8 array
    const PATCH_SIZE_SCALE_RATIO = Math.ceil(Math.min(window.innerWidth / 256, window.innerHeight / 256)); // patch size scale up ratio
    const IMAGE_PLOT_SIZE_BASE = Math.min(window.innerWidth / 28, window.innerHeight / 28);

    const patch_indices=Array(Z_COUNT); // list of 2D arrays [[i,j],[i,j],...]
    const patch_coords=Array(Z_COUNT); // list of 2D arrays [[x,y],[x,y],...]
    const sample_list=Array(Z_COUNT); // list of 1D arrays [i,j,k,...]
    const sample_index_to_real_index=Array(Z_COUNT); // list of functions

    const patch_sample_map=Array(Z_COUNT); // list of 2D arrays, patch index to list of sample indexs

    const buffer_images={};

    let display_content=[]; // currently displayed contents
    // z level and x y position
    let z_current=1.5;
    let x_current=0.5;
    let y_current=0.5;

    let use_high_performance_data=false;
    // check xyz args from url (useful for locating the area of interests)
    (function(){
      const args = window.location.search;
      const kv = new URLSearchParams(args);
      if (kv.get('x')!=null) {
        x_current=parseFloat(kv.get('x'));
      }
      if (kv.get('y')!=null) {
        y_current=parseFloat(kv.get('y'));
      }
      if (kv.get('z')!=null) {
        z_current=parseFloat(kv.get('z'));
      }
      if (kv.get('hp')>0){
        use_high_performance_data=true;
      }

      if (use_high_performance_data){
        button_mode.innerHTML="show more";
      } else {
        button_mode.innerHTML="show less";
      }
    })();

    // add window.scroll(0, 0) to restore the viewing position in ios browsers
    bake_background.onclick=function(e){if (e.target == bake_background){window.scroll(0, 0);bake_background.style.zIndex=null;}};
    bake_output.onclick=function(e){if (e.target == bake_output){window.scroll(0, 0);bake_background.style.zIndex=null;}};

    button_mode.addEventListener('click',(e)=>{
      update_url_arg();
      let url = window.location.href;
      if (url.includes('hp=')){
        if (use_high_performance_data){
          url = url.replaceAll('hp=1','hp=0');
        } else {
          url = url.replaceAll('hp=0','hp=1');
        }
      } else {
        if (use_high_performance_data){
          url=url + '&hp=0';
        } else {
          url=url + '&hp=1';
        }
      }
      window.location.href = url;
    });

    button_bake.addEventListener('click', (e)=>{
      remove_all_entries();
      for (let c of display_content){
        const selected_item = c[0];
        const selected_real_index = sample_index_to_real_index[Math.floor(z_current)](selected_item);
        const url = urllist[indexlist[selected_real_index]];
        // const name = namelist[indexlist[selected_real_index]];
        const url_thumb = "https://storage.googleapis.com/zfguo_pretrained_models/thumbs/" + selected_real_index + ".jpg";
        add_entry(url,url_thumb);
      }
      document.getElementById("bake_background").style.zIndex=2;
    });

    let img_plot_size=IMAGE_PLOT_SIZE_BASE;
    function update_image_plot_size(){
      img_plot_size = IMAGE_PLOT_SIZE_BASE * Math.pow(1.23,z_current);
    }

    function get_image_plot_size() {return img_plot_size;}

    function update_url_arg(){
      const url = window.location.href.split('?');
      const base = url[0];
      let args_new='';
      let and_synbol='';

      if (url.length>1){
        const pairs = url[1].split('&');
        for (let kv of pairs){
          const k = kv.split('=')[0];
          if (k!='x' && k != 'y' && k != 'z'){
            args_new = args_new + and_synbol + kv;
            and_synbol='&'
          }
        }
      }

      args_new = args_new + and_synbol + 'x=' + x_current +'&y=' + y_current + '&z=' + z_current;

      const url_new = base + "?" + args_new;
      // console.log(url_new);
      window.history.replaceState('','',url_new);
    }

    // decode NPY format
    function make_arr(descr, arr, offset){
      // console.log('descr',descr);
      if (descr=="|u1") {
        return new Uint8Array(arr,offset);
      } else if (descr=="<i4") {
        return new Int32Array(arr,offset);
      } else if (descr=="<f4") {
        return new Float32Array(arr,offset);
      } else if (descr=="<f8") {
        return new Float64Array(arr,offset);
      } else {
        console.log("no implement");
      }
    }

    function parse_npy(buff) {
      // const version = arrayBufferContents.slice(6, 8); // Uint8-encoded
      const hlen = new DataView(buff.slice(8, 10)).getUint8(0);
      const offset = 10 + hlen;
      const hstr = new TextDecoder("utf-8").decode(
          new Uint8Array(buff.slice(10, 10 + hlen))
      ).toLowerCase().replaceAll("(","[").replaceAll("),","]").replaceAll(",]","]").replaceAll("'","\"");
      const header = JSON.parse(hstr);
      return {"data":make_arr(header["descr"], buff, offset), "shape": header["shape"]};
    }

    function get_map_size(z_float){
      return PATCH_SIZE_PX * Math.pow(2, z_float) * PATCH_SIZE_SCALE_RATIO;
    }

    function get_transformation(z_float, x, y, w_px=0, h_px=0) {
      // z_float: current zoom level, float
      // x: current x position relative to the ENTIRE MAP (i.e., [0, 1])
      // y: current y position relative to the ENTIRE MAP (i.e., [0, 1])
      const z = z_float; // no value inspection, turst the input
      // const z = Math.min(Z_MAX, Math.max(Z_MIN, z_float));
      const z_int = Math.floor(z);
      const scale = Math.pow(2, z - z_int) * PATCH_SIZE_SCALE_RATIO; // the resizing ratio of 256 x 256 patches [1, 2)
      const size_px = PATCH_SIZE_PX * Math.pow(2, z_float) * PATCH_SIZE_SCALE_RATIO;

      return [-x*size_px + w_px/2, -y*size_px + h_px/2, scale];
    }

    function draw_next_level_preview(ctx, z_float, x, y, lv=1, color='white'){
      // x and y are canvas center relative to the entire map
      z_float=z_float+lv;
      const win_scale = 2**lv;
      const coord_scale = 2**(-lv);
      const dot_size_base=3;
      const dot_scale = Math.max(1/dot_size_base, 1.3**(-lv));
      ctx.fillStyle = color;

      const z = Math.min(Z_MAX, Math.max(Z_MIN, z_float));
      const w_px = ctx.canvas.width * win_scale;//  = window.innerWidth;
      const h_px = ctx.canvas.height * win_scale;// = window.innerHeight;

      const z_int = Math.floor(z);

      const [tx,ty,s] = get_transformation(z_float, x, y, w_px, h_px);

      const pi = patch_indices[z_int];
      const pc = patch_coords[z_int];

      const u_min = -tx/s;
      const u_max = (w_px-tx)/s;

      const v_min = -ty/s;
      const v_max = (h_px-ty)/s;

      const map_size = get_map_size(z);
      const grid_size = Math.pow(2, z_int);
      const i_range = Math.ceil(grid_size * w_px / map_size)
      const j_range = Math.ceil(grid_size * h_px / map_size)
      const i_center = Math.floor(x * grid_size);
      const j_center = Math.floor(y * grid_size);
      // console.log(grid_size);
      for (let di=-i_range; di<=i_range; di++){
        const i = di+i_center;
        if (i>=0 && i < grid_size){
          for (let dj=-j_range; dj<=j_range; dj++){
            const j=dj+j_center;
            if (j>=0 && j < grid_size){
              const patch_index = i * grid_size + j;
              const sample_list = patch_sample_map[z_int][patch_index];
              if (sample_list!=null){
                for (let sample_index of sample_list){
                  let [u,v]=pc.data.slice(sample_index*2, sample_index*2+2);

                  u=(u+i*PATCH_SIZE_PX);
                  v=(v+j*PATCH_SIZE_PX);

                  if (u>u_min && u<u_max && v>v_min && v<v_max){
                    u = u*s + tx;
                    v = v*s + ty;
                    ctx.fillRect(u * coord_scale,v * coord_scale, dot_size_base * dot_scale, dot_size_base * dot_scale);
                  }
                }
              }
            }
          }
        }
      }
    }

    function draw_patches(ctx, z_float, x, y) {
      // update_url_arg();
      update_image_plot_size();
      // x and y are canvas center relative to the entire map
      ctx.canvas.width  = window.innerWidth;
      ctx.canvas.height = window.innerHeight;

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      if (z_float < Z_COUNT-1.01){
        draw_next_level_preview(ctx, z_float, x, y, 1);
      }
      if (z_float < Z_COUNT-2.01){
        draw_next_level_preview(ctx, z_float, x, y, 2);
      }
      if (z_float < Z_COUNT-3.01){
        draw_next_level_preview(ctx, z_float, x, y, 3);
      }

      const w_px = ctx.canvas.width;//  = window.innerWidth;
      const h_px = ctx.canvas.height;// = window.innerHeight;

      const z = z_float;
      const z_int = Math.floor(z);

      const [tx,ty,s] = get_transformation(z_float, x, y, w_px, h_px);

      const pi = patch_indices[z_int];
      const pc = patch_coords[z_int];

      // add IMAGE_PLOT_SIZE to avoid image showing / disappearing effecr
      const img_plot_size=get_image_plot_size();
      const u_min = (-img_plot_size-tx)/s;
      const u_max = (w_px-tx + img_plot_size)/s;

      const v_min = (-img_plot_size-ty)/s;
      const v_max = (h_px-ty + img_plot_size)/s;

      display_content=[]; // contents which are interactable

      // new implementation, from center patch to outside patches, until no items are added
      const map_size = get_map_size(z);
      const grid_size = Math.pow(2, z_int);
      const i_range = Math.ceil(grid_size * w_px / map_size)
      const j_range = Math.ceil(grid_size * h_px / map_size)
      const i_center = Math.floor(x * grid_size);
      const j_center = Math.floor(y * grid_size);

      for (let di=-i_range; di<=i_range; di++){
        const i = di+i_center;
        if (i>=0 && i < grid_size){
          for (let dj=-j_range; dj<=j_range; dj++){
            const j=dj+j_center;
            if (j>=0 && j < grid_size){
              const patch_index = i * grid_size + j;
              const sample_list = patch_sample_map[z_int][patch_index];
              if (sample_list!=null){
                for (let sample_index of sample_list){
                  let [u,v]=pc.data.slice(sample_index*2, sample_index*2+2);

                  u=(u+i*PATCH_SIZE_PX);
                  v=(v+j*PATCH_SIZE_PX);

                  if (u>u_min && u<u_max && v>v_min && v<v_max){
                    u = u*s + tx;
                    v = v*s + ty;
                    ctx.fillRect(u,v,5,5); // fill in the pixel at (10,10)
                    display_content.push([sample_index, u, v]);

                    const real_index = sample_index_to_real_index[z_int](sample_index);
                    if (buffer_images[real_index]==null){
                      // add buffer image and set onload event
                      buffer_images[real_index] = new BufferImage(real_index, ctx, u, v, z);
                    } else {
                      // update uv coordinate and draw
                      buffer_images[real_index].u=u;
                      buffer_images[real_index].v=v;
                      buffer_images[real_index].z=z;
                      buffer_images[real_index].draw();
                    }
                  }
                }
              }
            }
          }
        }
      }

      // draw_next_level_preview(ctx, z_float+1, x, y);
    }

    class BufferImage{
      constructor(index, ctx, u, v, z){
        this.index=index;
        const r_url_thumb = "https://storage.googleapis.com/zfguo_pretrained_models/thumbs/" + index + ".jpg";
        this.img = new Image();
        this.img.src=r_url_thumb;

        this.u=u;
        this.v=v;
        this.z=z;
        this.ctx=ctx;

        this.img.onload=(()=>{
          this.img.width=128;
          this.img.height=128;
          this.draw();
          this.img.onload=null;
        });
      }

      draw(){
        if (this.z==z_current){
          const img_plot_size=get_image_plot_size();
          this.ctx.drawImage(this.img,this.u-img_plot_size/2,this.v-img_plot_size/2, img_plot_size, img_plot_size);
        }
      }
    }
  </script>

  <script type="module">
    console.log("module starts");

    function fetch_operation(path, callback=null, callback_async=null){
      return (function(){
        // return the operation as a callable function
        // console.log('loading', path);
        fetch(path, {}).then((resp)=>{
          resp.arrayBuffer().then((buff)=>{
            const npy = parse_npy(buff);
            if (callback!=null){
              callback(npy);
            }

            if (callback_async!=null){
              callback_async();
            }
          });
        });
      });
    }

    // register GUI events, which is the final step after successfully loading the data
    function regist_events(){
      const cnv = document.getElementById("main_canvas");
      const ctx = cnv.getContext("2d");

      let cur_mapsize=get_map_size(z_current);

      let x_down=0;
      let y_down=0;
      let button=-1;
      let timestamp=-1;
      let pinch_dist=-1;
      let no_open_link=false;
      let no_touch_drag=false;
      // initialize
      draw_patches(ctx, z_current, x_current, y_current);

      function drage_canvas(xpx, ypx){
        const xscale = cnv.width / cnv.clientWidth;
        const yscale = cnv.height / cnv.clientHeight;
        // dx and dy in rendering px
        let dx = Math.round(xscale * (x_down-xpx));
        let dy = Math.round(yscale * (y_down-ypx));

        // dx and dy relative to entire map
        dx /= cur_mapsize;
        dy /= cur_mapsize;

        x_down = xpx;
        y_down = ypx;

        x_current+=dx;
        y_current+=dy;

        draw_patches(ctx, z_current, x_current, y_current);
      }

      function update_cursor(xpx, ypx){
        const image_plot_size=get_image_plot_size();

        const xscale = cnv.width / cnv.clientWidth;
        const yscale = cnv.height / cnv.clientHeight;
        // detect element
        let x =  xscale * xpx;
        let y = yscale * ypx;

        let selected_item=-1;
        for (let i=0;i<display_content.length;i++){
          if (Math.abs(display_content[i][1]-x)<=image_plot_size/2 && Math.abs(display_content[i][2]-y)<=image_plot_size/2){
            selected_item = display_content[i][0];
            break;
          }
        }
        if (selected_item>=0){
          cnv.style.cursor="pointer";
        } else {
          cnv.style.cursor="default";
        }
      }

      function open_link(xpx, ypx){
        const image_plot_size=get_image_plot_size();

        const xscale = cnv.width / cnv.clientWidth;
        const yscale = cnv.height / cnv.clientHeight;
        // detect element
        let x =  xscale * xpx;
        let y = yscale * ypx;

        let selected_item=-1;
        let lastDist=-1;
        for (let i=0;i<display_content.length;i++){
          const dx = Math.abs(display_content[i][1]-x);
          const dy = Math.abs(display_content[i][2]-y);
          if (dx<=image_plot_size/2 && dy<=image_plot_size/2){
            if (selected_item==-1){
              selected_item = display_content[i][0];
              lastDist = dx*dx + dy*dy;
            } else {
              const dist = dx*dx + dy*dy;
              if (dist < lastDist){
                lastDist=dist;
                selected_item = display_content[i][0];
              }
            }
            // break;
          }
        }
        if (selected_item>=0){
          window.open(urllist[indexlist[sample_index_to_real_index[Math.floor(z_current)](selected_item)]], '_blank');
        }
      }

      function zoom_in_out(mousex, mousey, z_prev, z_current){
        const z_delta = z_current - z_prev;

        let old_mapsize=get_map_size(z_prev);
        cur_mapsize=get_map_size(z_current);

        const xscale = cnv.width / cnv.clientWidth;
        const yscale = cnv.height / cnv.clientHeight;

        // dx and dy in rendering px
        let dx = Math.round(xscale * (cnv.width / 2 - mousex));
        let dy = Math.round(yscale * (cnv.height / 2 - mousey));
        // dx and dy relative to entire map
        dx = dx / old_mapsize - dx / cur_mapsize;
        dy = dy / old_mapsize - dy / cur_mapsize;

        x_current-=dx;
        y_current-=dy;

        draw_patches(ctx, z_current, x_current, y_current);
        update_cursor(mousex, mousey);
      }

      window.addEventListener("resize", (e)=>{
        cnv.width=window.innerWidth;
        cnv.height=window.innerHeight;
        draw_patches(ctx, z_current, x_current, y_current);
      });

      cnv.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }

      cnv.addEventListener("wheel", (e)=>{
        e.preventDefault();
        const z_prev = z_current;
        z_current+=0.3*Math.sign(e.wheelDeltaY);
        z_current = Math.min(Z_MAX, Math.max(Z_MIN, z_current));
        const z_delta = z_current - z_prev;

        if (z_delta != 0){
          zoom_in_out(e.offsetX, e.offsetY, z_prev, z_current);
          update_url_arg();
        }
      });

      cnv.addEventListener('click', (e)=>{
        if (e.timeStamp - timestamp < 300) {
          open_link(e.offsetX, e.offsetY);
        }
        timestamp = e.timeStamp;
      });

      cnv.addEventListener('mousedown', (e)=>{
        update_cursor(e);
        x_down = e.offsetX;
        y_down = e.offsetY;
        button = e.button;
        timestamp = e.timeStamp;
      });

      cnv.addEventListener('mousemove', (e)=>{
        update_cursor(e.offsetX, e.offsetY);
        if (button==0){ // drag
          drage_canvas(e.offsetX, e.offsetY);
        }
      });

      cnv.addEventListener('mouseup', (e)=>{
        button = -1;
        update_url_arg();
      });

      cnv.addEventListener('touchstart', (e)=>{
        e.preventDefault();

        // prevent two touch event happen too close
        no_open_link = (e.timeStamp - timestamp < 300);
        no_touch_drag=no_open_link;

        timestamp=e.timeStamp;
        x_down = e.targetTouches[0].clientX;// - rect.left;
        y_down = e.targetTouches[0].clientY;// - rect.top;
      });

      cnv.addEventListener('touchmove', (e)=>{
        e.preventDefault();
        no_open_link=true; // if move is detected, no open link??

        if (e.targetTouches.length==1 && !no_touch_drag){
          drage_canvas(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
        } else if (e.targetTouches.length==2){
          // no_open_link=true;
          no_touch_drag=true;

          var dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY);

          // pinch detection
          if (pinch_dist>0){
            const z_prev = z_current;
            z_current += 0.01*(dist - pinch_dist);
            z_current = Math.min(Z_MAX, Math.max(Z_MIN, z_current));
            const z_delta = z_current - z_prev;

            zoom_in_out(
              (e.touches[0].clientX + e.touches[1].clientX)/2,
              (e.touches[0].clientY + e.touches[1].clientY)/2,
              z_prev, z_current);
          }
          pinch_dist=dist;
        }
      });

      cnv.addEventListener('touchend', (e)=>{
        e.preventDefault();
        if (e.timeStamp - timestamp < 300 && !no_open_link) {
          // openlink when no zooming was made
          open_link(x_down, y_down);
        }
        if (!no_touch_drag || pinch_dist>0) {
          update_url_arg();
        }
        timestamp = e.timeStamp;
        pinch_dist=-1;
      });
    }

    // build patch-id - element map to increase performance
    // this should be done after successfully loading the data
    function build_patch_item_map(){
      for (let z=0;z<Z_COUNT; z++){
        const sample_num = patch_indices[z].shape[0];
        const grid_size = Math.pow(2,z);
        const sample_map = Array(grid_size * grid_size);

        for (let index=0; index < sample_num; index++){
          const [i,j]=patch_indices[z].data.slice(index*2, index*2+2);
          const patch_index_int = i*grid_size+j;

          if (sample_map[patch_index_int]==null){
            sample_map[patch_index_int]=[];
          }
          sample_map[patch_index_int].push(index);
        }

        patch_sample_map[z]=sample_map;
      }
    }

    function build_indexing_func(){
      for (let z=0;z<Z_COUNT; z++){
        if (z<Z_COUNT-1){
          sample_index_to_real_index[z]=((x)=>{return sample_list[z].data[x];});
        } else {
          sample_index_to_real_index[z]=((x)=>{return x;});
        }
      }
      // console.log(sample_list[0]);
    }

    function init(){
      build_patch_item_map();
      build_indexing_func();
      regist_events();
      indicator.parentNode.parentNode.removeChild(indicator.parentNode);
    }

    let root_path='./anarchdailylexicon_tsne/data/z';
    if (use_high_performance_data){
      root_path='./anarchdailylexicon_tsne/data_high_performance/z';
    }
    // load all z-level informations
    // using nested functions, and returns the out-most function for calling (initiate the nested chain)
    let load_data_entry=init; // a callable which register the gui functions, or null if nothing to do
    for (let i=0; i<Z_COUNT; i++){
      const pi = fetch_operation(root_path+i+'_pi.npy', (x)=>{indicator.innerHTML='Loading Indexes ' + i + '...'; patch_indices[i]=x;},load_data_entry);
      const pc = fetch_operation(root_path+i+'_pc.npy',(x)=>{patch_coords[i]=x;},pi);
      if (i<Z_COUNT-1){
        const ps = fetch_operation(root_path+i+'_i.npy',(x)=>{sample_list[i]=x;},pc);
        load_data_entry = ps;
      } else {
        load_data_entry = pc;
      }
    }

    load_data_entry();
  </script>
</body>
</html>
